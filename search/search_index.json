{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the _Lib wiki!</p> <p>_Lib is a Dungeondraft mod that offers additional API to simplify implementing certain features like configs and improve mod compatibility.</p>"},{"location":"#using-_lib","title":"Using _Lib","text":"<p>To be able to access _Lib's Api put the following at the top of your mods <code>start()</code> method: <pre><code>Engine.emit_signal(\"_lib_register_mod\", self)\n</code></pre> Alternatively check if the signal exists first to ensure _Lib is actually enabled: <pre><code>if not Engine.has_signal(\"_lib_register_mod\"):\nreturn\nEngine.emit_signal(\"_lib_register_mod\", self)\n</code></pre></p> <p>After registering your mod with _Lib you will now have an entry <code>Global.API</code> available that contains all of the _Lib APIs.</p>"},{"location":"#current-api","title":"Current API","text":"<ul> <li>ApiApi</li> <li>InputMapApi</li> <li>ModConfigApi</li> <li>ModSignalingApi</li> <li>PreferencesWindowApi</li> </ul>"},{"location":"ApiApi/","title":"ApiApi","text":"<p>A Registry for all _Lib APIs.</p>"},{"location":"ApiApi/#description","title":"Description","text":"<p>All _Lib APIs are registered to and accessed from the ApiApi. It is accessed via <code>Global.API</code> and can also be used by mods to registers APIs of their own. APIs registered to the ApiApi can be directly referenced from it.</p>"},{"location":"ApiApi/#example","title":"Example:","text":"<pre><code># register the ModApi\nGlobal.API.register(\"ModApi\", mod_api_instance)\n# call some method on the ModApi\nGlobal.API.ModApi.some_method()\n</code></pre>"},{"location":"ApiApi/#methods","title":"Methods","text":"<p> void register ( String api, Object api ) </p>"},{"location":"ApiApi/#signals","title":"Signals","text":"<p>api_registered ( String api_id, Object api ):</p> <p> - Emitted when an API is registered. </p>"},{"location":"ApiApi/#method-descriptions","title":"Method Descriptions","text":"<p>void register ( String api, Object api ):</p> <p> Registers an API under the name api </p>"},{"location":"ModSignalingApi/","title":"ModSignalingApi","text":"<p>Enables inter-mod communication.</p>"},{"location":"ModSignalingApi/#description","title":"Description","text":"<p>The ModSignalingApi is intended to be used for inter-mod communication. It uses the existing signal system but offers connect_deffered to connect to a signal either immediately or whenever it actually becomes available. It furthermore emits signal_registered ( String signal_id ) when a new user signal is added to it.</p>"},{"location":"ModSignalingApi/#methods","title":"Methods","text":"<p> void connect_deferred ( String signal_id, Object target, String method, Array binds, int flags ) void add_user_signal ( String signal_id, Array arguments ) </p>"},{"location":"ModSignalingApi/#signals","title":"Signals","text":"<p>signal_registered ( String signal_id ):</p> <p> Emitted whenever a new user signal is added to the ModSignalingAPi. </p>"},{"location":"ModSignalingApi/#method-descriptions","title":"Method Descriptions","text":"<p>void connect_deferred ( String signal_id, Object target, String method, Array binds, int flags ):</p> <p> Forwards the call directly to Object#connect if a signal signal_id exists. Otherwise queues the call and runs it when a user signal signal_id is added. </p> <p>void add_user_signal ( String signal_id, Array arguments ):</p> <p> Overrides Object#add_user_signal. Additionally emits signal_registered ( String signal_id ) after the user signal has been added. </p>"},{"location":"PreferencesWindowApi/","title":"PreferencesWindowApi","text":"<p>An Api that makes adding additional tabs to the preferences window easy.</p>"},{"location":"PreferencesWindowApi/#description","title":"Description","text":"<p>The PreferencesWindowApi makes it possible to easily add new tabs to the preferences window using create_category ( String name, Control container ). The attached container can then interact with the preferences window using the provided methods and signals.</p>"},{"location":"PreferencesWindowApi/#methods","title":"Methods","text":"<p> Control create_category ( String name, Control container ) void show_close ( ) void show_back ( ) WindowDialog get_preferences_window ( ) </p>"},{"location":"PreferencesWindowApi/#signals","title":"Signals","text":"<p>back_pressed ( Variant ):</p> <p> Emitted whenever the back button is pressed. </p> <p>apply_pressed ( Variant ):</p> <p> Emitted whenever the apply button is pressed. </p> <p>about_to_show ( Variant ):</p> <p> Emitted right before the preferences window would open up. Use this signal to for example rebuild Trees. </p>"},{"location":"PreferencesWindowApi/#method-descriptions","title":"Method Descriptions","text":"<p>Control create_category ( String name, Control container ):</p> <p> Creates a new category in the preferences window under the name name. Attaches container if given or generates a blank VBoxContainer as the new category panel and returns it. </p> <p>void show_close ( ):</p> <p> Makes the close button show and hides the back button. Each tab has their close/ back button visibility maintained seperately. </p> <p>void show_back ( ):</p> <p> Makes a back button show in the preferences window instead of the normal close button. Each tab has their close/ back button visibility maintained seperately. </p> <p>WindowDialog get_preferences_window ( ):</p> <p> Returns the PreferencesWindow WindowDialog. </p>"},{"location":"InputMapApi/","title":"InputMapApi","text":"<p>An Api for attaching InputEventEmitterNodes that emit signals for cancellable input events.</p>"},{"location":"InputMapApi/#description","title":"Description","text":"<p>The InputMapApi makes it possible to attach an InputEventEmitterNode as a child of a node using get_or_append_event_emitter ( Node node ). It additionally handles synchronization of ShortcutConfigNodes and has some methods for serializing and deserializing InputEventKeys.</p>"},{"location":"InputMapApi/#methods","title":"Methods","text":"<p> void define_actions ( String category, Dictionary actions ) InputEventKey deserialize_event ( String string ) String serialize_event ( InputEventKey event ) String event_as_string ( InputEventKey event ) ActionConfigSyncAgent get_agent ( String action ) ActionConfigSyncAgent get_or_create_agent ( String action, float deadzone ) InputEventEmitterNode get_or_append_event_emitter ( Node node ) InputEventEmitterNode master_event_emitter ( ) </p>"},{"location":"InputMapApi/#method-descriptions","title":"Method Descriptions","text":"<p>void define_actions ( String category, Dictionary actions ):</p> <p> Registers actions to the InputMap from a Dictionary and adds them to the Shortcuts menu. actions may consist of nested dictionaries to define categories inside the Shortcuts menu. Shortcut entries can either be a String defining the action name or an Array. The arrays first entry defines the action name while the following entries define the default shortcuts, either as a String denoting the shortcut or a InputEventKey. Example: <p><pre><code>var input_definitions: Dictionary = {\n\"Some Shortcut\": [\"shortcut1\", \"Ctrl+P\", \"L\"],\n\"Some Category\":{\n\"Other Shortcut\": \"shortcut2\",\n\"Third Shortcut\": \"shortcut3\"\n}\n}\nself.Global.API.InputMapApi.define_actions(\"Example Mod\", input_definitions)\n</code></pre> </p> <p>InputEventKey deserialize_event ( String string ):</p> <p> Deserializes an InputEventKey from string. </p> <p>String serialize_event ( InputEventKey event ):</p> <p> Serializes event into a String. </p> <p>String event_as_string ( InputEventKey event ):</p> <p> Turns event into a human readable String representation. </p> <p>ActionConfigSyncAgent get_agent ( String action ):</p> <p> Gets the ActionConfigSyncAgent for action. </p> <p>ActionConfigSyncAgent get_or_create_agent ( String action, float deadzone ):</p> <p> Gets or creates the ActionConfigSyncAgent for action. </p> <p>InputEventEmitterNode get_or_append_event_emitter ( Node node ):</p> <p> Gets the InputEventEmitterNode attached to node or creates one if necessary. </p> <p>InputEventEmitterNode master_event_emitter ( ):</p> <p> Gets the InputEventEmitterNode attached to the Master node (owner of Editor &amp; World) or creates one if necessary. </p>"},{"location":"InputMapApi/InputEventEmitterNode/","title":"InputEventEmitterNode","text":""},{"location":"ModConfigApi/","title":"ModConfigApi","text":"<p>An Api that enables creating a mod config accessible from the \"Mods\" menu.</p>"},{"location":"ModConfigApi/#description","title":"Description","text":"<p>The ModConfigApi manages mod configs. It's only method creates a ConfigBuilder that offers methods for building a mod config that is automatically saved into a given file by the ModConfigApi.</p>"},{"location":"ModConfigApi/#methods","title":"Methods","text":"<p> ConfigBuilder create_config ( String mod_id, String title, String config_file ) </p>"},{"location":"ModConfigApi/#method-descriptions","title":"Method Descriptions","text":"<p>ConfigBuilder create_config ( String mod_id, String title, String config_file ):</p> <p> Creates a new ConfigBuilder for the mod with id mod_id. The mod config will automatically be saved into and loaded from config_file. </p>"}]}