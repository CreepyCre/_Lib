{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Home  <p>Welcome to the _Lib wiki!</p> <p>_Lib is a Dungeondraft mod that offers additional API to simplify implementing certain features like configs and improve mod compatibility.</p>"},{"location":"#using-_lib","title":"Using _Lib","text":"<p>To be able to access _Lib's Api put the following at the top of your mods <code>start()</code> method: <pre><code>Engine.emit_signal(\"_lib_register_mod\", self)\n</code></pre> Alternatively check if the signal exists first to ensure _Lib is actually enabled: <pre><code>if not Engine.has_signal(\"_lib_register_mod\"):\nreturn\nEngine.emit_signal(\"_lib_register_mod\", self)\n</code></pre></p> <p>After registering your mod with _Lib you will now have an entry <code>Global.API</code> available that contains all of the _Lib APIs.</p>"},{"location":"#current-api","title":"Current API","text":"<ul> <li>ApiApi</li> <li>Logger</li> <li>AccessorApi</li> <li>ComponentsApi</li> <li>HistoryApi</li> <li>InputMapApi</li> <li>LayerApi</li> <li>ModConfigApi</li> <li>ModSignalingApi</li> <li>PreferencesWindowApi</li> <li>Util</li> </ul>"},{"location":"ApiApi/","title":"ApiApi","text":"<p>A Registry for all _Lib APIs.</p>"},{"location":"ApiApi/#description","title":"Description","text":"<p>All _Lib APIs are registered to and accessed from the ApiApi. It is accessed via <code>Global.API</code> and can also be used by mods to registers APIs of their own. APIs registered to the ApiApi can be directly referenced from it.</p>"},{"location":"ApiApi/#example","title":"Example:","text":"<pre><code># register the ModApi\nGlobal.API.register(\"ModApi\", mod_api_instance)\n# call some method on the ModApi\nGlobal.API.ModApi.some_method()\n</code></pre>"},{"location":"ApiApi/#methods","title":"Methods","text":"<p> void register ( String api, Object api ) </p>"},{"location":"ApiApi/#signals","title":"Signals","text":"<p>api_registered ( String api_id, Object api ):   Emitted when an API is registered. </p>"},{"location":"ApiApi/#method-descriptions","title":"Method Descriptions","text":"<p>void register ( String api, Object api ):   Registers an API under the name api </p>"},{"location":"LayerApi/","title":"LayerApi","text":"<p>Offers methods for adding/ removing user layers.</p>"},{"location":"LayerApi/#description","title":"Description","text":"<p>The LayerApi offers methods for adding and removing user layers. It's important to note the internal methods used are not officially supported by Dungeondraft and the Api will likely be superseded by Dungeondraft core Api in the future.</p>"},{"location":"LayerApi/#methods","title":"Methods","text":"<p> void add_layer ( int layer, String name ) void add_layers ( Dictionary layers ) Dictionary get_layers ( Level level ) Dictionary get_user_layers ( Level level ) void remove_layer ( int layer ) void remove_layers ( Array layers ) void rename_layer ( int layer, String name ) </p>"},{"location":"LayerApi/#constants","title":"Constants","text":"<p> Dictionary LOCKED_LAYERS {-500: \"Terrain\",-300: \"Caves\",-200: \"Floor\",0: \"Water\",500: \"Portals\",600: \"Walls\",800: \"Roofs\"} </p>"},{"location":"LayerApi/#method-descriptions","title":"Method Descriptions","text":"<p>void add_layer ( int layer, String name ):   Shorthand for adding a single layer via add_layers. </p> <p>void add_layers ( Dictionary layers ):   Adds the layers provided in layers where the keys are the z_index and the values are the layer names. When specifiying level the layers will only be added to that specific Level. </p> <p>void remove_layer ( int layer ):   Shorthand for removing a single layer via remove_layers. </p> <p>void remove_layers ( Array layers ):   Removes the layers provided in layers by their z_index. When specifiying level the layers will only be removed from that specific Level. </p> <p>void rename_layer ( int layer, String name ):   Renames layer layer to name. When specifiying level the layer will only be renamed in that specific Level. </p> <p>Dictionary get_layers ( Level level ):   Gets all layers in level. </p> <p>Dictionary get_user_layers ( Level level ):   Gets all user (= non-locked) layers in level. </p>"},{"location":"ModSignalingApi/","title":"ModSignalingApi","text":"<p>Enables inter-mod communication.</p>"},{"location":"ModSignalingApi/#description","title":"Description","text":"<p>The ModSignalingApi is intended to be used for inter-mod communication. It uses the existing signal system but offers connect_deffered to connect to a signal either immediately or whenever it actually becomes available. It furthermore emits signal_registered ( String signal_id ) when a new user signal is added to it.</p>"},{"location":"ModSignalingApi/#methods","title":"Methods","text":"<p> void add_user_signal ( String signal_id, Array arguments = [] ) void connect_deferred ( String signal_id, Object target, String method, Array binds = [], int flags = 0 ) </p>"},{"location":"ModSignalingApi/#signals","title":"Signals","text":"<p>signal_registered ( String signal_id ):   Emitted whenever a new user signal is added to the ModSignalingAPi. </p>"},{"location":"ModSignalingApi/#method-descriptions","title":"Method Descriptions","text":"<p>void connect_deferred ( String signal_id, Object target, String method, Array binds = [], int flags = 0 ):   Forwards the call directly to Object#connect if a signal signal_id exists. Otherwise queues the call and runs it when a user signal signal_id is added. </p> <p>void add_user_signal ( String signal_id, Array arguments = [] ):   Overrides Object#add_user_signal. Additionally emits signal_registered ( String signal_id ) after the user signal has been added. </p>"},{"location":"PreferencesWindowApi/","title":"PreferencesWindowApi","text":"<p>An Api that makes adding additional tabs to the preferences window easy.</p>"},{"location":"PreferencesWindowApi/#description","title":"Description","text":"<p>The PreferencesWindowApi makes it possible to easily add new tabs to the preferences window using create_category ( String name, Control container = _create_default_container() ). The attached container can then interact with the preferences window using the provided methods and signals.</p>"},{"location":"PreferencesWindowApi/#methods","title":"Methods","text":"<p> Control create_category ( String name, Control container = _create_default_container() ) WindowDialog get_preferences_window ( ) void show_back ( ) void show_close ( ) </p>"},{"location":"PreferencesWindowApi/#signals","title":"Signals","text":"<p>back_pressed ( ):   Emitted whenever the back button is pressed. </p> <p>apply_pressed ( ):   Emitted whenever the apply button is pressed. </p> <p>about_to_show ( ):   Emitted right before the preferences window would open up. Use this signal to for example rebuild Trees. </p>"},{"location":"PreferencesWindowApi/#method-descriptions","title":"Method Descriptions","text":"<p>Control create_category ( String name, Control container = _create_default_container() ):   Creates a new category in the preferences window under the name name. Attaches container if given or generates a blank VBoxContainer as the new category panel and returns it. </p> <p>void show_close ( ):   Makes the close button show and hides the back button. Each tab has their close/ back button visibility maintained seperately. </p> <p>void show_back ( ):   Makes a back button show in the preferences window instead of the normal close button. Each tab has their close/ back button visibility maintained seperately. </p> <p>WindowDialog get_preferences_window ( ):   Returns the PreferencesWindow WindowDialog. </p>"},{"location":"AccessorApi/","title":"AccessorApi","text":"<p>Api for iterating over all godot Object to aquire usually inaccessible references.</p>"},{"location":"AccessorApi/#description","title":"Description","text":"<p>The AccessorApi offers the ability to iterate over all instances of Object using a visitor pattern. It is intended for aquiring some references that would usually be inaccessible inside C# objects.</p>"},{"location":"AccessorApi/#methods","title":"Methods","text":"<p> Object accept ( ObjectVisitor visitor ) ConfigFile config ( ) </p>"},{"location":"AccessorApi/#method-descriptions","title":"Method Descriptions","text":"<p>Object accept ( ObjectVisitor visitor ):   This will have the AccessorApi make your visitor visit all Object. </p> <p>ConfigFile config ( ):   Returns the ConfigFile reference used for Dungeondrafts own config. Any changes to existing config entries will be lost, however, new entries will be saved alongside the default entries. Can be used to read the current config settings. </p>"},{"location":"AccessorApi/ObjectVisitor/","title":"ObjectVisitor","text":""},{"location":"AccessorApi/ObjectVisitor/#description","title":"Description","text":"<p>This represents any Object implementing visit ( Object obj ) and track ( ) methods.</p>"},{"location":"AccessorApi/ObjectVisitor/#methods","title":"Methods","text":"<p> bool track ( ) bool visit ( Object obj ) </p>"},{"location":"AccessorApi/ObjectVisitor/#method-descriptions","title":"Method Descriptions","text":"<p>bool visit ( Object obj ):   Sequentially called with every existing Object as parameter. Loop will be aborted when returning false. </p> <p>bool track ( ):   Called when visit loop is aborted or has finished. If this returns true the next time this same visitor is used with the AccessorApi it will skip all previously visited Object. </p>"},{"location":"ComponentsApi/","title":"ComponentsApi","text":"<p>An Api for attaching persistent data to map objects.</p>"},{"location":"ComponentsApi/#description","title":"Description","text":"<p>The ComponentsApi makes it possible to attach a Component to a map object such as a Prop or Wall.</p>"},{"location":"ComponentsApi/#methods","title":"Methods","text":"<p> NodeType node_type ( Node node ) ComponentKey register ( String identifier, component_script, int flags ) </p>"},{"location":"ComponentsApi/#signals","title":"Signals","text":"<p>level_added ( node ):   Emitted when a Level is added to the World. </p> <p>pattern_added ( node ):   Emitted when a PatternShape is added to any Level. </p> <p>wall_added ( node ):   Emitted when a Wall is added to any Level. </p> <p>portal_free_added ( node ):   Emitted when a free standing Portal is added to any Level. </p> <p>portal_wall_added ( node ):   Emitted when a wall bound Portal is added to any Level. </p> <p>material_added ( node ):   Emitted when a MaterialMesh is added to any Level. </p> <p>path_added ( node ):   Emitted when a Pathway is added to any Level. </p> <p>prop_added ( node ):   Emitted when a Prop is added to any Level. </p> <p>light_added ( node ):   Emitted when a Light2D is added to any Level. </p> <p>roof_added ( node ):   Emitted when a Roof is added to any Level. </p> <p>text_added ( node ):   Emitted when a Text is added to any Level. </p>"},{"location":"ComponentsApi/#enumerations","title":"Enumerations","text":"<p>enum NodeType:<ul><li>TYPE_WORLD = 0</li><li>TYPE_LEVEL = 1</li><li>TYPE_PATTERN = 2</li><li>TYPE_WALL = 3</li><li>TYPE_PORTAL_FREE = 4</li><li>TYPE_PORTAL_WALL = 5</li><li>TYPE_MATERIAL = 6</li><li>TYPE_PATH = 7</li><li>TYPE_PROP = 8</li><li>TYPE_LIGHT = 9</li><li>TYPE_ROOF = 10</li><li>TYPE_TEXT = 11</li></ul>  Denotes the type of a map node. May be directly converted to the corresponding flag using bit shift: <pre><code>var prop_flag = 1 &lt;&lt; TYPE_PROP\n</code></pre> </p>"},{"location":"ComponentsApi/#constants","title":"Constants","text":"<p> int FLAG_ALL 0b111111111111 int FLAG_LEVEL 0b000000000010 int FLAG_LIGHT 0b001000000000 int FLAG_MATERIAL 0b000001000000 int FLAG_PATH 0b000010000000 int FLAG_PATTERN 0b000000000100 int FLAG_PORTAL 0b000000110000 int FLAG_PORTAL_FREE 0b000000010000 int FLAG_PORTAL_WALL 0b000000100000 int FLAG_PROP 0b000100000000 int FLAG_ROOF 0b010000000000 int FLAG_TEXT 0b100000000000 int FLAG_WALL 0b000000001000 int FLAG_WITH_NODE_ID 0b111110111100 int FLAG_WORLD 0b000000000001 </p>"},{"location":"ComponentsApi/#method-descriptions","title":"Method Descriptions","text":"<p>ComponentKey register ( String identifier, component_script, int flags ):   Registers a new component with identifier as its unique identifier. component_factory may be either the GDScript of a Component or a ComponentFactory. It will be used to instantiate and deserialize the Component flags is any combination of node type flags to determine which types of nodes the component is applicable to. Setting lazy to false will cause the component to be automatically attached to any node shortly after it enters the scene. The returned ComponentKey can be used to access the Component on applicable nodes. </p> <p>NodeType node_type ( Node node ):   Returns the NodeType of node. </p>"},{"location":"ComponentsApi/Component/","title":"Component","text":""},{"location":"ComponentsApi/Component/#description","title":"Description","text":"<p>Let's you attach persistent data to nodes. The ComponentsApi will call a components constructor with the node as parameter for component creation should no create method exist.</p>"},{"location":"ComponentsApi/Component/#methods","title":"Methods","text":"<p> void component_node_removed ( Node node ) Component static create ( Node node ) Component static deserialize ( Node node, Variant data ) void detached ( Node node ) Variant serialize ( Node node ) </p>"},{"location":"ComponentsApi/Component/#method-descriptions","title":"Method Descriptions","text":"<p>static Component create ( Node node ):   Optional method offering more fine control over component creation than just having a constructor. </p> <p>Variant serialize ( Node node ):   Implement to return serialized Component data. </p> <p>static Component deserialize ( Node node, Variant data ):   Implement to deserialize a Component on node from data </p> <p>void detached ( Node node ):   Optional method that is called just before the component is detached from node. </p> <p>void component_node_removed ( Node node ):   Optional method that is called when node (the node this Component is attached to) is removed from the scene tree </p>"},{"location":"ComponentsApi/ComponentFactory/","title":"ComponentFactory","text":""},{"location":"ComponentsApi/ComponentFactory/#description","title":"Description","text":"<p>Can be used during Component registration instead of its GDScript to gain more fine control over Component creation and deserialization.</p>"},{"location":"ComponentsApi/ComponentFactory/#methods","title":"Methods","text":"<p> Component create ( Node node ) Component deserialize ( Node node, Variant data ) </p>"},{"location":"ComponentsApi/ComponentFactory/#method-descriptions","title":"Method Descriptions","text":"<p>Component create ( Node node ):   Creates and returns a Component attached to node. </p> <p>Component deserialize ( Node node, Variant data ):   Deserialized Component on node from data. </p>"},{"location":"ComponentsApi/ComponentKey/","title":"ComponentKey","text":""},{"location":"ComponentsApi/ComponentKey/#description","title":"Description","text":"<p>Let's you access components on applicable nodes.</p>"},{"location":"ComponentsApi/ComponentKey/#methods","title":"Methods","text":"<p> void detach_component ( Node node ) Component get_component ( Node node ) bool has_component ( Node node ) bool is_applicable ( Node node ) </p>"},{"location":"ComponentsApi/ComponentKey/#method-descriptions","title":"Method Descriptions","text":"<p>bool is_applicable ( Node node ):   Check whether this Component is applicable to node. </p> <p>bool has_component ( Node node ):   Checks whether this Component is attached to node. </p> <p>Component get_component ( Node node ):   Returns the corresponding Component attached to node or creates one if necessary. </p> <p>void detach_component ( Node node ):   Will detach a Component from node and call Component#component_node_removed just before. </p>"},{"location":"HistoryApi/","title":"HistoryApi","text":"<p>Let's you add records to the undo history.</p>"},{"location":"HistoryApi/#description","title":"Description","text":"<p>The HistoryApi makes it possible to add undo/redo records which seemlessly integrate with DungeonDrafts built in History. A record is represented by any Object that has <code>undo()</code> and <code>redo()</code> methods.</p>"},{"location":"HistoryApi/#methods","title":"Methods","text":"<p> void record ( Object history_record ) bool redo ( ) bool undo ( ) </p>"},{"location":"HistoryApi/#signals","title":"Signals","text":"<p>recorded ( history_record ):   Emitted when a new record is added to the history. </p> <p>dropped ( history_record, type ):   Emitted when a record is dropped from the history, either due to exceeding the length of the history or due to being in the redo history when a new Record is recorded. </p> <p>undo_begin ( history_record ):   Emitted before a records undo method is called. </p> <p>undo_end ( history_record ):   Emitted before a records undo method has finished processing. </p> <p>redo_begin ( history_record ):   Emitted before a records redo method is called. </p> <p>redo_end ( history_record ):   Emitted before a records redo method has finished processing. </p>"},{"location":"HistoryApi/#enumerations","title":"Enumerations","text":"<p>enum HistoryType:<ul><li>UNDO = 0</li><li>REDO = 1</li></ul>  Denotes the type of history a record is currently recorded in. </p>"},{"location":"HistoryApi/#method-descriptions","title":"Method Descriptions","text":"<p>void record ( Object history_record ):   Adds history_record to the history. </p> <p>bool undo ( ):   Calls <code>undo()</code> on the next relevant record of the history. </p> <p>bool redo ( ):   Calls <code>redo()</code> on the next relevant record of the history. </p>"},{"location":"HistoryApi/Record/","title":"Record","text":"<p>Represents a record that can be recorded to the HistoryApi.</p>"},{"location":"HistoryApi/Record/#description","title":"Description","text":"<p>There is no actual Record class, this page simply serves as a blueprint for implementing a record.</p> <p>A Record represents an entry in the HistoryApi. It is required to implement undo ( ) and redo ( ) methods which are supposed to undo/ redo a change to the map. A record may also provide a record_type ( ) method that returns a key for differentiating different record types. The records script is used as its record type if no other type is provided. Should a specific record type be added to the history more times than max_count ( ) allows, then the oldest record of that type (and all other older records) will be dropped. Should a record implement a dropped ( HistoryType type ) method it will be called when it is dropped, where ``</p>"},{"location":"HistoryApi/Record/#methods","title":"Methods","text":"<p> void dropped ( HistoryType type ) int idle_frames ( ) int max_count ( ) Variant record_type ( ) bool redo ( ) bool undo ( ) </p>"},{"location":"HistoryApi/Record/#method-descriptions","title":"Method Descriptions","text":"<p>bool undo ( ):   Called by the HistoryApi to start the undo process of the Record. </p> <p>bool redo ( ):   Called by the HistoryApi to start the redo process of the Record. </p> <p>void dropped ( HistoryType type ):   Called by the HistoryApi when the Record is dropped from the history, either due to exceeding the length of the history or due to being in the redo history when a new Record is recorded. The supplied HistoryType denotes whether the record was in the undo or redo history at time of dropping. </p> <p>int max_count ( ):   Called by the HistoryApi to determine the maximum amount of records of this type that can be recorded before the oldest records will be discarded from the history. </p> <p>Variant record_type ( ):   Called by the HistoryApi. It's return value is used as a key to to compare max_count ( ) against. Different types of records may implement this method incase they want to share the same maximum history records. </p> <p>int idle_frames ( ):   In case a Record needs a certain amount of frames to fully process its undo or redo method a Record may implement this method to denote a certain amount of idle frames to wait before emitting undo_end or redo_end. </p>"},{"location":"InputMapApi/","title":"InputMapApi","text":"<p>An Api for attaching InputEventEmitterNodes that emit signals for cancellable input events.</p>"},{"location":"InputMapApi/#description","title":"Description","text":"<p>The InputMapApi makes it possible to attach an InputEventEmitterNode as a child of a node using get_or_append_event_emitter ( Node node ). It additionally handles synchronization of ShortcutConfigNodes and has some methods for serializing and deserializing InputEventKeys.</p>"},{"location":"InputMapApi/#methods","title":"Methods","text":"<p> void define_actions ( String category, Dictionary actions ) InputEventKey deserialize_event ( String string ) String event_as_string ( InputEventKey event ) ActionConfigSyncAgent get_agent ( String action ) InputEventEmitterNode get_or_append_event_emitter ( Node node ) ActionConfigSyncAgent get_or_create_agent ( String action, float deadzone = 0.5 ) InputEventEmitterNode master_event_emitter ( ) String serialize_event ( InputEventKey event ) </p>"},{"location":"InputMapApi/#method-descriptions","title":"Method Descriptions","text":"<p>void define_actions ( String category, Dictionary actions ):   Registers actions to the InputMap from a Dictionary and adds them to the Shortcuts menu. actions may consist of nested dictionaries to define categories inside the Shortcuts menu. Shortcut entries can either be a String defining the action name or an Array. The arrays first entry defines the action name while the following entries define the default shortcuts, either as a String denoting the shortcut or a InputEventKey. Example: <p><pre><code>var input_definitions: Dictionary = {\n\"Some Shortcut\": [\"shortcut1\", \"Ctrl+P\", \"L\"],\n\"Some Category\":{\n\"Other Shortcut\": \"shortcut2\",\n\"Third Shortcut\": \"shortcut3\"\n}\n}\nself.Global.API.InputMapApi.define_actions(\"Example Mod\", input_definitions)\n</code></pre> </p> <p>InputEventKey deserialize_event ( String string ):   Deserializes an InputEventKey from string. </p> <p>String serialize_event ( InputEventKey event ):   Serializes event into a String. </p> <p>String event_as_string ( InputEventKey event ):   Turns event into a human readable String representation. </p> <p>ActionConfigSyncAgent get_agent ( String action ):   Gets the ActionConfigSyncAgent for action. </p> <p>ActionConfigSyncAgent get_or_create_agent ( String action, float deadzone = 0.5 ):   Gets or creates the ActionConfigSyncAgent for action. </p> <p>InputEventEmitterNode get_or_append_event_emitter ( Node node ):   Gets the InputEventEmitterNode attached to node or creates one if necessary. </p> <p>InputEventEmitterNode master_event_emitter ( ):   Gets the InputEventEmitterNode attached to the Master node (owner of Editor &amp; World) or creates one if necessary. </p>"},{"location":"InputMapApi/ActionConfigSyncAgent/","title":"ActionConfigSyncAgent","text":"<p>Responsible for synchronization of shortcuts between multiple shortcut config nodes.</p>"},{"location":"InputMapApi/ActionConfigSyncAgent/#description","title":"Description","text":"<p>Every action defined through the InputMapApi has its own ActionConfigSyncAgent created. It is used by the ModConfigApi to ensure shortcut config nodes displaying the same shortcut stay synchronized with eachother.</p>"},{"location":"InputMapApi/ActionConfigSyncAgent/#methods","title":"Methods","text":"<p> void add_event ( InputEventKey event ) void added_item ( ) void deleted_item ( int index ) String get_action ( ) Array get_action_list ( ) bool is_saved ( ) void switch ( InputEventKey from, InputEventKey to, int index ) </p>"},{"location":"InputMapApi/ActionConfigSyncAgent/#signals","title":"Signals","text":"<p>switched ( InputEventKey from, InputEventKey to, int index ):   Emitted when switch ( InputEventKey from, InputEventKey to, int index ) is called when a shortcut is changed in a shortcut config and forwards the parameters. from and to are the previous and new InputEventKey respectively. index is the index of the item changed in the actions event list indexed by their order in the config tree. </p> <p>deleted ( int index ):   Emitted when deleted_item ( int index ) is called when a shortcut is deleted in a shortcut config and forwards the parameters. index denotes the index of the item deleted in the actions event list indexed by their order in the config tree. </p> <p>added ( ):   Emitted when added_item ( ) is called when a shortcut is deleted in a shortcut config and forwards the parameters. </p>"},{"location":"InputMapApi/ActionConfigSyncAgent/#method-descriptions","title":"Method Descriptions","text":"<p>String get_action ( ):   Returns the action this ActionConfigSyncAgent handles as a String. </p> <p>Array get_action_list ( ):   Retuns the InputEvent Array bound to this ActionConfigSyncAgents action. </p> <p>void switch ( InputEventKey from, InputEventKey to, int index ):   Emits switched ( InputEventKey from, InputEventKey to, int index ). Call to indicate that at the index from has been switched with to. </p> <p>void deleted_item ( int index ):   Emits deleted ( int index ). Call to indicate that the shortcut at index has been cleared. </p> <p>void added_item ( ):   Emits added ( ). Call to indicate that a new shortcut has been added to this ActionConfigSyncAgents action. </p> <p>void add_event ( InputEventKey event ):   Adds event to this ActionConfigSyncAgents action. </p> <p>bool is_saved ( ):   Returns a bool that indicates whether the action is being saved to any config. Shortcut config nodes only allow modifying shortcuts that are actually being saved. </p>"},{"location":"InputMapApi/InputEventEmitterNode/","title":"InputEventEmitterNode","text":"<p>A Node that emits cancellable input event signals.</p>"},{"location":"InputMapApi/InputEventEmitterNode/#description","title":"Description","text":"<p>An InputEventEmitterNode can be attached as the child of any node via the InputMapApi. Any time the Node#_input, Node#_unhandled_input or Node#_unhandled_key_input method is called on it it will emit a signal accordingly. The signals provide the InputEventEmitterNode whose accept_event ( ) method can then be called to prevent further propagation of the InputEvent.</p>"},{"location":"InputMapApi/InputEventEmitterNode/#methods","title":"Methods","text":"<p> void accept_event ( ) </p>"},{"location":"InputMapApi/InputEventEmitterNode/#signals","title":"Signals","text":"<p>input ( InputEvent event, InputEventEmitterNode emitter ):   Emitted when Node#_input is called on this Node. </p> <p>unhandled_input ( InputEvent event, InputEventEmitterNode emitter ):   Emitted when Node#_unhandled_input is called on this Node. </p> <p>unhandled_key_input ( InputEventKey event, InputEventEmitterNode emitter ):   Emitted when Node#_unhandled_key_input is called on this Node. </p>"},{"location":"InputMapApi/InputEventEmitterNode/#method-descriptions","title":"Method Descriptions","text":"<p>void accept_event ( ):   Call to prevent further propagation of the received InputEvent. </p>"},{"location":"Logger/","title":"Logger","text":"<p>It's a Logger.</p>"},{"location":"Logger/#description","title":"Description","text":"<p>This is a Logger that logs with a standardised prefix in the form of: <pre><code>[hh:mm:ss] [LEVEL] [Mod Name] [&lt;optional ModClass&gt;:&lt;optional line number&gt;]: message\n</code></pre> It is recommended to use for_class to provide a unique logger for each individual GDScript. It's also possible to provide a unique prefix formatter using set_formatter or with_formatter</p>"},{"location":"Logger/#methods","title":"Methods","text":"<p> void debug ( String clazz, int line, String message, Array args ) void error ( String clazz, int line, String message, Array args ) void fatal ( String clazz, int line, String message, Array args ) ClassLogger for_class ( clazz ) void info ( String clazz, int line, String message, Array args ) void set_formatter ( FuncRef prefix_formatter = PREFIX_FORMATTER ) void warn ( String clazz, int line, String message, Array args ) Logger with_formatter ( FuncRef prefix_formatter = PREFIX_FORMATTER ) </p>"},{"location":"Logger/#enumerations","title":"Enumerations","text":"<p>enum LogLevel:<ul><li>OFF = 0</li><li>FATAL = 1</li><li>ERROR = 2</li><li>WARN = 3</li><li>INFO = 4</li><li>DEBUG = 5</li></ul>  Denotes the log level. </p>"},{"location":"Logger/#constants","title":"Constants","text":"<p> FuncRef MILLIS_PREFIX_FORMATTER funcref(self, \"build_prefix_millis\") FuncRef PREFIX_FORMATTER funcref(self, \"build_prefix\") </p>"},{"location":"Logger/#method-descriptions","title":"Method Descriptions","text":"<p>ClassLogger for_class ( clazz ):   Creates a ClassLogger which pre-supplies the clazz for the logging methods. clazz may be either a String containing the class name or a relevant instance of the class/ the GDScript itself with a CLASS_NAME constant providing the name as a String. </p> <p>void debug ( String clazz, int line, String message, Array args ):   Logs a message at debug level. clazz denotes the GDScript that is being logged from, line denotes the line number and args is the parameters the message will be formatted with. clazz, line and args may each be omitted. </p> <p>void info ( String clazz, int line, String message, Array args ):   Logs a message at info level. clazz denotes the GDScript that is being logged from, line denotes the line number and args is the parameters the message will be formatted with. clazz, line and args may each be omitted. </p> <p>void warn ( String clazz, int line, String message, Array args ):   Logs a message at warn level. clazz denotes the GDScript that is being logged from, line denotes the line number and args is the parameters the message will be formatted with. clazz, line and args may each be omitted. </p> <p>void error ( String clazz, int line, String message, Array args ):   Logs a message at error level. clazz denotes the GDScript that is being logged from, line denotes the line number and args is the parameters the message will be formatted with. clazz, line and args may each be omitted. </p> <p>void fatal ( String clazz, int line, String message, Array args ):   Logs a message at fatal level. clazz denotes the GDScript that is being logged from, line denotes the line number and args is the parameters the message will be formatted with. clazz, line and args may each be omitted. </p> <p>void set_formatter ( FuncRef prefix_formatter = PREFIX_FORMATTER ):   Sets prefix_formatter as this loggers prefix formatter. The prefix formatter is a FuncRef to any method with signature:  <pre><code>func format_prefix(level: int, mod_name: String, clazz = null, line: int = -1)\n</code></pre>  Should clazz or line be equal to their default value, then this signifies that they are missing, so they should be omitted when formatting the log prefix. </p> <p>Logger with_formatter ( FuncRef prefix_formatter = PREFIX_FORMATTER ):   Creates and returns a new Logger with prefix_formatter as the loggers prefix formatter. The prefix formatter is a FuncRef to any method with signature:  <pre><code>func format_prefix(level: int, mod_name: String, clazz = null, line: int = -1)\n</code></pre>  Should clazz or line be equal to their default value, then this signifies that they are missing, so they should be omitted when formatting the log prefix. </p>"},{"location":"Logger/ClassLogger/","title":"ClassLogger","text":"<p>It's a Logger with the class already supplied.</p>"},{"location":"Logger/ClassLogger/#description","title":"Description","text":"<p>This is a ClassLogger that logs with a standardised prefix in the form of: <pre><code>[hh:mm:ss] [LEVEL] [Mod Name] [ModClass:&lt;optional line number&gt;]: message\n</code></pre> A ClassLogger already has 'ModClass' supplied through being created using for_class. It's also possible to provide a unique prefix formatter using set_formatter or with_formatter</p>"},{"location":"Logger/ClassLogger/#methods","title":"Methods","text":"<p> void debug ( int line, String message, Array args ) void error ( int line, String message, Array args ) void fatal ( int line, String message, Array args ) ClassLogger for_class ( clazz ) void info ( int line, String message, Array args ) void set_formatter ( FuncRef prefix_formatter = PREFIX_FORMATTER ) void warn ( int line, String message, Array args ) ClassLogger with_formatter ( FuncRef prefix_formatter = PREFIX_FORMATTER ) </p>"},{"location":"Logger/ClassLogger/#enumerations","title":"Enumerations","text":"<p>enum LogLevel:<ul><li>OFF = 0</li><li>FATAL = 1</li><li>ERROR = 2</li><li>WARN = 3</li><li>INFO = 4</li><li>DEBUG = 5</li></ul>  Denotes the log level. </p>"},{"location":"Logger/ClassLogger/#constants","title":"Constants","text":"<p> FuncRef MILLIS_PREFIX_FORMATTER funcref(self, \"build_prefix_millis\") FuncRef PREFIX_FORMATTER funcref(self, \"build_prefix\") </p>"},{"location":"Logger/ClassLogger/#method-descriptions","title":"Method Descriptions","text":"<p>ClassLogger for_class ( clazz ):   Creates a ClassLogger which pre-supplies the clazz for the logging methods. clazz may be either a String containing the class name or a relevant instance of the class/ the GDScript itself with a CLASS_NAME constant providing the name as a String. </p> <p>void debug ( int line, String message, Array args ):   Logs a message at debug level. line denotes the line number and args is the parameters the message will be formatted with. line and args may each be omitted. </p> <p>void info ( int line, String message, Array args ):   Logs a message at info level. line denotes the line number and args is the parameters the message will be formatted with. line and args may each be omitted. </p> <p>void warn ( int line, String message, Array args ):   Logs a message at warn level. line denotes the line number and args is the parameters the message will be formatted with. line and args may each be omitted. </p> <p>void error ( int line, String message, Array args ):   Logs a message at error level. line denotes the line number and args is the parameters the message will be formatted with. line and args may each be omitted. </p> <p>void fatal ( int line, String message, Array args ):   Logs a message at fatal level. line denotes the line number and args is the parameters the message will be formatted with. line and args may each be omitted. </p> <p>void set_formatter ( FuncRef prefix_formatter = PREFIX_FORMATTER ):   Sets prefix_formatter as this loggers prefix formatter. The prefix formatter is a FuncRef to any method with signature:  <pre><code>func format_prefix(level: int, mod_name: String, clazz = null, line: int = -1)\n</code></pre>  Should clazz or line be equal to their default value, then this signifies that they are missing, so they should be omitted when formatting the log prefix. </p> <p>ClassLogger with_formatter ( FuncRef prefix_formatter = PREFIX_FORMATTER ):   Creates and returns a new ClassLogger with prefix_formatter as the loggers prefix formatter. The prefix formatter is a FuncRef to any method with signature:  <pre><code>func format_prefix(level: int, mod_name: String, clazz = null, line: int = -1)\n</code></pre>  Should clazz or line be equal to their default value, then this signifies that they are missing, so they should be omitted when formatting the log prefix. </p>"},{"location":"ModConfigApi/","title":"ModConfigApi","text":"<p>An Api that enables creating a mod config accessible from the \"Mods\" menu.</p>"},{"location":"ModConfigApi/#description","title":"Description","text":"<p>The ModConfigApi manages mod configs. It's only method creates a ConfigBuilder that offers methods for building a mod config that is automatically saved into a given file by the ModConfigApi. See ConfigBuilder for a detailed explanation on the usage.</p>"},{"location":"ModConfigApi/#methods","title":"Methods","text":"<p> ConfigBuilder create_config ( String config_file = \"user://mod_config/\" + mod_meta[\"unique_id\"].to_lower().replace(\" \", \"\").replace(\".\", \"_\") + \".json\", String title = mod_meta[\"name\"], String mod_id = mod_meta[\"unique_id\"] ) </p>"},{"location":"ModConfigApi/#method-descriptions","title":"Method Descriptions","text":"<p>ConfigBuilder create_config ( String config_file = \"user://mod_config/\" + mod_meta[\"unique_id\"].to_lower().replace(\" \", \"\").replace(\".\", \"_\") + \".json\", String title = mod_meta[\"name\"], String mod_id = mod_meta[\"unique_id\"] ):   Creates a new ConfigBuilder for the mod with id mod_id. The mod config will automatically be saved into and loaded from config_file. </p>"},{"location":"ModConfigApi/ConfigAgent/","title":"ConfigAgent","text":"<p>Provides access to config values.</p>"},{"location":"ModConfigApi/ConfigAgent/#description","title":"Description","text":"<p>The ConfigAgents main purpose is to provide access to config values. It mirrors the exact layout of the actual config. For example, if a config looks like: <pre><code>{\n\"key1\" : \"value1\"\n\"sub_category\": {\n\"key2\" : 123,\n\"key3\" : true\n}\n}\n</code></pre> Then the values may be accessed and set as follows: <pre><code>config.key1 = \"new_value\"\nconfig.sub_category.key2 = 101\nconfig.sub_category.key3 = false\n</code></pre> The values are directly retrieved from and stored to the config nodes that make up the config screen.</p>"},{"location":"ModConfigApi/ConfigAgent/#methods","title":"Methods","text":"<p> void load_cfg ( ) void mark_dirty ( ) void save_cfg ( bool force = false ) </p>"},{"location":"ModConfigApi/ConfigAgent/#method-descriptions","title":"Method Descriptions","text":"<p>void save_cfg ( bool force = false ):   Saves the config to its config file. Set force to true to force saving even if the config is unchanged. </p> <p>void load_cfg ( ):   Loads the config from its config file. </p> <p>void mark_dirty ( ):   Marks the config as dirty so it will be saved on the next save_cfg call. </p>"},{"location":"ModConfigApi/ConfigBuilder/","title":"ConfigBuilder","text":"<p>Makes it possible to construct a config menu in a fairly human readable manner.</p>"},{"location":"ModConfigApi/ConfigBuilder/#description","title":"Description","text":"<p>The ConfigBuilder is used to create mod configs. It is supposed to provide an intuitive and human readable api for doing so. To achieve this, it relies on method chaining so the code for setting up a config may look structurally similar to the resulting config file. The following general types of methods are provided:</p> <ul> <li>Scene tree navigation (enter ( ) and exit ( ))</li> <li>Node attachment and creation (e.g. add_node ( Control node, bool legible_unique_name = false ))</li> <li>Node configuration (e.g. size_expand_fill ( ) and with ( String property, value ))</li> <li>Node referencing (see ref ( String reference_name ))</li> </ul> <p>A ConfigBuilder is obtained by creating a mod config using the ModConfigApi: <pre><code>var mod_id: String = \"CreepyCre.ExampleMod\"\nvar config_title: String = \"Example Mod Config\"\nvar config_file: String = self.Global.Root + \"config.json\"\nvar builder = self.Global.API.ModConfigApi.create_config(mod_id, config_title, config_file)\n</code></pre></p> <p>Control nodes may then be created and appended to the config screen using their appropriate methods. The config can be built at the end usingbuild ( bool should_load = true, bool should_free = true ): <pre><code># multiline method chaining does not allow comments inbetween\nvar config = builder\\\n    .label(\"Hello World!\")\\\n    .check_button(\"key1\", true, \"This is a check Button!\")\\\n    .build()\n</code></pre> Writing a <code>\\</code> at the end of a line allows for method chaining across multiple lines. Config nodes such as the CheckButton created throughcheck_button ( String save_entry, bool default_value, String text = \"\" )take a save_entry and default_value as parameters. The save_entry is the key the setting will be saved under in the config file. </p> <p>For appending nodes as children of other nodes enter ( ) and exit ( ) allow hopping into and out of nodes: <pre><code>builder\\\n    .v_box_container().enter()\\\n        .h_box_container().enter()\\\n            .label(\"Hello World!\")\\\n        .exit()\\\n    .exit()\n</code></pre> Mind the indentation in this example. Though it serves no actual purpose indenting methods indicating the depth of the node entered is recommended for increased readability.</p> <p>Also mind the optional save_entry parameter available for container type node creation. Supplying save_entry will create sub categories for all contained config nodes. For example: <pre><code>var config = builder\\\n            .h_box_container(\"category\").enter()\\\n                .check_button(\"key1\", true, \"Hello\")\\\n                .check_box(\"key2\", true, \"World\")\\\n            .exit()\\\n            .line_edit(\"key3\", \"This is the default text.\")\\\n            .build()\n</code></pre></p> <p>Will result in the following config: <pre><code>{\n\"category\": {\n\"key1\": true,\n\"key2\": true\n}\n\"key3\": \"This is the default text.\"\n}\n</code></pre></p> <p>Config values may then be accessed and modified through the ConfigAgent returned when building the config: <pre><code># access value\nprint(config.category.key1)\n# change value\nconfig.category.key1 = false\n</code></pre></p> <p>For styling the nodes there are some shorthand methods available likesize_flags_h ( int flags ) or rect_min_size ( Vector2 min_size ).For accessing properties and methods that do not have shorthand equivalents usewith ( String property, value ) and call_on ( String method_name, args... ) which both perform actions on the last node created. with directly sets the given property to value while call_on forwards its parameters to Object#call: <pre><code># hidden spin box. idk why you'd want this, it's just an example\nbuilder.spin_box(\"key\", 70)\\\n        .with(\"suffix\",\"dpi\")\\\n        .call_on(\"hide\")\n</code></pre></p> <p>For connecting node signals use connect_current and connect_to_prop. While connect_current forwards its parameters to connect, connect_to_prop actually forwards the signal to a utility methods that always updates the property property of target with the emitted value. </p> <p>How would you handle connecting different config nodes signals together? To avoid having to keep references to nodes which would interrupt code flow use ref ( String reference_name ). It assigns the key reference_name to the last node so it may later be retrieved using get_ref ( String reference_name ) or be called on usingcall_on_ref ( String reference_name, String method_name, args... ),connect_ref ( String reference_name, String signal_name, Object target, String method_name, Array binds = [], int flags = 0 ) andconnect_ref_to_prop ( String reference_name, String signal_name, target, String property ). E.g.: <pre><code>builder\\\n    .label().ref(\"slider_label\")\\\n    .h_slider(\"key\", 42).size_flags_h(Control.SIZE_EXPAND_FILL)\\\n        .connect_to_prop(\"loaded\", builder.get_ref(\"slider_label\"), \"text\")\\\n        .connect_to_prop(\"value_changed\", builder.get_ref(\"slider_label\"), \"text\")\\\n</code></pre> In this example the text label has been connected to the sliders <code>loaded</code> and <code>value_changed</code> signals to make it display the current slider value.</p>"},{"location":"ModConfigApi/ConfigBuilder/#methods","title":"Methods","text":"<p> ConfigBuilder add_color_override ( String name, Color color ) ConfigBuilder add_constant_override ( String name, int constant ) ConfigBuilder add_font_override ( String name, Font font ) ConfigBuilder add_icon_override ( String name, Texture texture ) ConfigBuilder add_node ( Control node, bool legible_unique_name = false ) ConfigBuilder add_node_direct ( Control node, bool legible_unique_name = false ) ConfigBuilder add_shader_override ( String name, Shader shader ) ConfigBuilder add_stylebox_override ( String name, StyleBox stylebox ) ConfigBuilder aspect_ratio_container ( String save_entry = \"\" ) ConfigAgent build ( bool should_load = true, bool should_free = true ) ConfigBuilder call_on ( String method_name, args... ) ConfigBuilder call_on_ref ( String reference_name, String method_name, args... ) ConfigBuilder center_container ( String save_entry = \"\" ) ConfigBuilder check_box ( String save_entry, bool default_value, String text = \"\" ) ConfigBuilder check_button ( String save_entry, bool default_value, String text = \"\" ) ConfigBuilder color_picker ( String save_entry, Color default_value ) ConfigBuilder color_picker_button ( String save_entry, Color default_value ) ConfigBuilder color_rect ( Color color ) ConfigBuilder connect_current ( String signal_name, Object target, String method_name, Array binds = [], int flags = 0 ) ConfigBuilder connect_ref ( String reference_name, String signal_name, Object target, String method_name, Array binds = [], int flags = 0 ) ConfigBuilder connect_ref_to_prop ( String reference_name, String signal_name, target, String property ) ConfigBuilder connect_to_prop ( String signal_name, target, String property ) ConfigBuilder enter ( ) ConfigBuilder exit ( ) ConfigBuilder extend ( String save_entry, Control node ) ConfigBuilder flatten ( bool value = true ) ConfigAgent get_agent ( ) Control get_current ( ) Control get_ref ( String reference_name ) Control get_root ( ) ConfigBuilder grid_container ( String save_entry = \"\" ) ConfigBuilder h_box_container ( String save_entry = \"\" ) ConfigBuilder h_separator ( ) ConfigBuilder h_slider ( String save_entry, float default_value ) ConfigBuilder h_split_container ( String save_entry = \"\" ) ConfigBuilder label ( String text = \"\" ) ConfigBuilder line_edit ( String save_entry, String default_value, bool require_hit_enter = true ) ConfigBuilder margin_container ( String save_entry = \"\" ) ConfigBuilder nine_patch_rect ( ) ConfigBuilder option_button ( String save_entry, int default_value, Array options ) ConfigBuilder panel ( ) ConfigBuilder panel_container ( String save_entry = \"\" ) ConfigBuilder rect_min_size ( Vector2 min_size ) ConfigBuilder rect_min_x ( float min_x ) ConfigBuilder rect_min_y ( float min_y ) ConfigBuilder rect_size ( Vector2 size ) ConfigBuilder rect_x ( float x ) ConfigBuilder rect_y ( float y ) ConfigBuilder ref ( String reference_name ) ConfigBuilder reference_rect ( ) ConfigBuilder rich_text_label ( String bbcode_text = \"\" ) ConfigBuilder scroll_container ( String save_entry = \"\" ) ConfigBuilder shortcuts ( String save_entry, Dictionary definitions ) ConfigBuilder size_expand_fill ( ) ConfigBuilder size_flags_h ( int flags ) ConfigBuilder size_flags_v ( int flags ) ConfigBuilder spin_box ( String save_entry, float default_value ) ConfigBuilder tab_container ( String save_entry = \"\" ) ConfigBuilder text_edit ( String save_entry, String default_value ) ConfigBuilder texture_rect ( Texture texture ) ConfigBuilder v_box_container ( String save_entry = \"\" ) ConfigBuilder v_separator ( ) ConfigBuilder v_slider ( String save_entry, float default_value ) ConfigBuilder v_split_container ( String save_entry = \"\" ) ConfigBuilder with ( String property, value ) ConfigBuilder wrap ( String save_entry, Control root_node, target_node = null ) </p>"},{"location":"ModConfigApi/ConfigBuilder/#method-descriptions","title":"Method Descriptions","text":"<p>ConfigBuilder enter ( ):   Enters the last Control appended so new nodes will be created as its children. </p> <p>ConfigBuilder exit ( ):   Exits the node previously entered. </p> <p>ConfigBuilder add_node ( Control node, bool legible_unique_name = false ):   Adds node as child of the node currently entered. </p> <p>ConfigBuilder add_node_direct ( Control node, bool legible_unique_name = false ):   Directly adds node as child of the node currently entered bypassing the get_target() call. </p> <p>ConfigBuilder with ( String property, value ):   Sets the property property to value on the most recent node. </p> <p>ConfigBuilder size_flags_h ( int flags ):   Sets the property Control#size_flags_horizontal to flags on the most recent node. </p> <p>ConfigBuilder size_flags_v ( int flags ):   Sets the property Control#size_flags_vertical to flags on the most recent node. </p> <p>ConfigBuilder size_expand_fill ( ):   Shorthand for: <pre><code>.size_flags_h(Control.SIZE_EXPAND_FILL)\\\n.size_flags_v(Control.SIZE_EXPAND_FILL)\n</code></pre> </p> <p>ConfigBuilder rect_min_size ( Vector2 min_size ):   Sets the property Control#rect_min_size to min_size on the most recent node. </p> <p>ConfigBuilder rect_min_x ( float min_x ):   Shorthand for: <pre><code>.rect_min_size(Vector2(min_x, builder.get_current().rect_min_size.y))\n</code></pre> </p> <p>ConfigBuilder rect_min_y ( float min_y ):   Shorthand for: <pre><code>.rect_min_size(Vector2(builder.get_current().rect_min_size.x, min_y))\n</code></pre> <p></p> <p>ConfigBuilder rect_size ( Vector2 size ):   Sets the property Control#rect_size to size on the most recent node. </p> <p>ConfigBuilder rect_x ( float x ):   Shorthand for: <pre><code>.rect_size(Vector2(x, builder.get_current().rect_size.y))\n</code></pre> </p> <p>ConfigBuilder rect_y ( float y ):   Shorthand for: <pre><code>.rect_size(Vector2(builder.get_current().rect_size.x, y))\n</code></pre> </p> <p>ConfigBuilder flatten ( bool value = true ):   Calls flatten(value) on the most recent node. Setting value to <code>true</code> will make the most recent node flatten its child config entries into its parent node. </p> <p>Control get_current ( ):   Returns the most recent node. </p> <p>ConfigBuilder ref ( String reference_name ):   Gives the most recent node the identifier reference_name so it can be retrieved later using get_ref ( String reference_name ) </p> <p>Control get_ref ( String reference_name ):   Returns the node with identifier reference_name. </p> <p>ConfigBuilder call_on ( String method_name, args... ):   Calls method method_name with arguments args on the most recent node. </p> <p>ConfigBuilder call_on_ref ( String reference_name, String method_name, args... ):   Calls method method_name with arguments args on node with identifier reference_name. </p> <p>ConfigBuilder connect_current ( String signal_name, Object target, String method_name, Array binds = [], int flags = 0 ):   Calls Object#connect on the most recent node using identical paramters. </p> <p>ConfigBuilder connect_ref ( String reference_name, String signal_name, Object target, String method_name, Array binds = [], int flags = 0 ):   Calls Object#connect on the node with identifier reference_name using identical paramters besides reference_name. </p> <p>ConfigBuilder connect_to_prop ( String signal_name, target, String property ):   Connects the signal signal_name from the most recent node such that the emitted value is applied to property :parameter:<code>property</code> in :parameter:<code>target</code>. </p> <p>ConfigBuilder connect_ref_to_prop ( String reference_name, String signal_name, target, String property ):   Connects the signal signal_name from the node with identifier reference_name such that the emitted value is applied to property :parameter:<code>property</code> in :parameter:<code>target</code>. </p> <p>ConfigBuilder add_color_override ( String name, Color color ):   Forwards call to Control#add_color_override on the most recent node. </p> <p>ConfigBuilder add_constant_override ( String name, int constant ):   Forwards call to Control#add_constant_override on the most recent node. </p> <p>ConfigBuilder add_font_override ( String name, Font font ):   Forwards call to Control#add_font_override on the most recent node. </p> <p>ConfigBuilder add_icon_override ( String name, Texture texture ):   Forwards call to Control#add_icon_override on the most recent node. </p> <p>ConfigBuilder add_shader_override ( String name, Shader shader ):   Forwards call to Control#add_shader_override on the most recent node. </p> <p>ConfigBuilder add_stylebox_override ( String name, StyleBox stylebox ):   Forwards call to Control#add_stylebox_override on the most recent node. </p> <p>ConfigBuilder wrap ( String save_entry, Control root_node, target_node = null ):   Wraps a scene in a WrappedControlConfigNode where root_node is the scene root and target_node is where new child nodes will be appended by the ConfigBuilder. The wrapped scenes config nodes will be saved into the category save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder extend ( String save_entry, Control node ):   Appends node as a child of the currently entered node and gives it config node capabilities by settings its script to ContainerExtensionConfigNode. </p> <p>ConfigBuilder check_button ( String save_entry, bool default_value, String text = \"\" ):   Appends a CheckButton config node with config key save_entry, default value default_value and text text. </p> <p>ConfigBuilder check_box ( String save_entry, bool default_value, String text = \"\" ):   Appends a CheckBox config node with config key save_entry, default value default_value and text text. </p> <p>ConfigBuilder h_slider ( String save_entry, float default_value ):   Appends an HSlider config node with config key save_entry and default value default_value. </p> <p>ConfigBuilder v_slider ( String save_entry, float default_value ):   Appends a VSlider config node with config key save_entry and default value default_value. </p> <p>ConfigBuilder spin_box ( String save_entry, float default_value ):   Appends a SpinBox config node with config key save_entry and default value default_value. </p> <p>ConfigBuilder color_picker ( String save_entry, Color default_value ):   Appends a ColorPicker config node with config key save_entry and default value default_value. </p> <p>ConfigBuilder color_picker_button ( String save_entry, Color default_value ):   Appends a ColorPickerButton config node with config key save_entry and default value default_value. </p> <p>ConfigBuilder option_button ( String save_entry, int default_value, Array options ):   Appends an OptionButton config node with config key save_entry, default value default_value and options options. The entries of options can either be Strings for a plain labelled option or dictionaries with possible entries <code>\"label\"</code>, <code>\"icon\"</code> and <code>\"meta\"</code>. Accessing the config value from the ConfigAgent will return the selected options meta if available or its label. The selected option can be changed through the ConfigAgent by setting it to either its index or its label: <pre><code>agent.some_option_button = 2 # this works\nagent.some_option_button = \"label goes here\" # this also works\n</code></pre> <p></p> <p>ConfigBuilder line_edit ( String save_entry, String default_value, bool require_hit_enter = true ):   Appends a LineEdit config node with config key save_entry and default value default_value. require_hit_enter configures whether the Enter key must be hit to update the config value. </p> <p>ConfigBuilder text_edit ( String save_entry, String default_value ):   Appends a TextEdit config node with config key save_entry and default value default_value. </p> <p>ConfigBuilder shortcuts ( String save_entry, Dictionary definitions ):   Appends a Tree config node with config key save_entry that contains shortcuts defined via definitions. definitions has to be structured equivalent to actions in InputMapApi#define_actions, though any default shortcuts will be ignored here. </p> <p>ConfigBuilder aspect_ratio_container ( String save_entry = \"\" ):   Appends an AspectRatioContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder center_container ( String save_entry = \"\" ):   Appends a CenterContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder h_box_container ( String save_entry = \"\" ):   Appends a HBoxContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder v_box_container ( String save_entry = \"\" ):   Appends a VBoxContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder grid_container ( String save_entry = \"\" ):   Appends a GridContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder h_split_container ( String save_entry = \"\" ):   Appends an HSplitContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder v_split_container ( String save_entry = \"\" ):   Appends a VSplitContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder margin_container ( String save_entry = \"\" ):   Appends a MarginContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder panel_container ( String save_entry = \"\" ):   Appends a PanelContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder scroll_container ( String save_entry = \"\" ):   Appends a ScrollContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder tab_container ( String save_entry = \"\" ):   Appends a TabContainer with config key save_entry. Setting save_entry to \"\" flattens the node. </p> <p>ConfigBuilder color_rect ( Color color ):   Appends a ColorRect with color as its color. </p> <p>ConfigBuilder h_separator ( ):   Appends an HSeparator. </p> <p>ConfigBuilder v_separator ( ):   Appends a VSeparator. </p> <p>ConfigBuilder label ( String text = \"\" ):   Appends a Label with text text. </p> <p>ConfigBuilder nine_patch_rect ( ):   Appends a NinePatchRect. </p> <p>ConfigBuilder panel ( ):   Appends a Panel. </p> <p>ConfigBuilder reference_rect ( ):   Appends a ReferenceRect. </p> <p>ConfigBuilder rich_text_label ( String bbcode_text = \"\" ):   Appends a bbcode enabled RichTextLabel with bbcode_text as its bbcode_text. </p> <p>ConfigBuilder texture_rect ( Texture texture ):   Appends a TextureRect with texture texture. </p> <p>ConfigAgent build ( bool should_load = true, bool should_free = true ):   Builds the config panel and returns the ConfigAgent. If should_load is set to true the config will be loaded upon building it. If should_free is set to true the ConfigBuilder will be freed after the config has been built. </p> <p>ConfigAgent get_agent ( ):   Returns the ConfigAgent </p> <p>Control get_root ( ):   Returns the root node of the config. </p>"},{"location":"Util/","title":"Util","text":"<p>Provides utility methods and classes.</p>"},{"location":"Util/#description","title":"Description","text":"<p>The Util class provides different utility methods and classes intended to streamline some of the more frequent necessities like resource loading.</p>"},{"location":"Util/#methods","title":"Methods","text":"<p> FileLoadingHelper create_loading_helper ( String root = mod.Global.Root + \"../../\" ) </p>"},{"location":"Util/#method-descriptions","title":"Method Descriptions","text":"<p>FileLoadingHelper create_loading_helper ( String root = mod.Global.Root + \"../../\" ):   Creates a FileLoadingHelper that provides some utility methods for resource and script loading. </p>"},{"location":"Util/FileLoadingHelper/","title":"FileLoadingHelper","text":"<p>Provides utility methods for loading resources and scripts.</p>"},{"location":"Util/FileLoadingHelper/#description","title":"Description","text":"<p>A FileLoadingHelper provides shorthand methods for loading resources and scripts from predefined folders.</p>"},{"location":"Util/FileLoadingHelper/#methods","title":"Methods","text":"<p> Texture load_icon ( String icon_path ) PackedScene load_scene ( String scene_path ) GDScript load_script ( String script_path ) Texture load_texture ( String texture_path ) </p>"},{"location":"Util/FileLoadingHelper/#method-descriptions","title":"Method Descriptions","text":"<p>GDScript load_script ( String script_path ):   Loads the script at: <p>root &gt; \"scripts\" &gt; script_path + \".gd\" </p> <p>PackedScene load_scene ( String scene_path ):   Loads the scene at: <p>root &gt; \"scenes\" &gt; scene_path + \".tscn\" </p> <p>Texture load_icon ( String icon_path ):   Loads the icon at: <p>root &gt; \"textures\" &gt; \"icons\" &gt; icon_path </p> <p>Texture load_texture ( String texture_path ):   Loads the texture at: <p>root &gt; \"textures\" &gt; texture_path </p>"}]}